/**
 * Copyright (c) 2015 CineApps
 * This source code is the property of CineApps.
 */
package com.cineapps.service;

import java.io.StringReader;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;

import com.cineapps.model.License;
import com.cineapps.utils.EncryptDecryptUtils;

public class LicenseService {

	private static final LicenseService service = new LicenseService();
	private License license;
	public static final String PRIVATE_KEY = "c76cfb76010511e491910800200c9a66";

	private LicenseService() {
		// private constructor
	}

	// Singleton getter method
	public static LicenseService getService() {
		return service;
	}

	/**
	 * Create a new license file using AES and a private key to encrypt the
	 * content. Protocol : - The key file is generated if is not yet. - Then,
	 * this key file is send to us for generate a license file corresponding to
	 * this key file. - We create a License instance with the decrypted key
	 * file, the limit date and the list of active modules. - Finally, the
	 * License instance is marshalled into string that is encrypted with the
	 * private key.
	 * 
	 * @param license
	 * @param dest
	 * @throws Exception
	 */
	public void generateLicense(License license, String dest) {
		try {
			// Marshall the license in xml string
			JAXBContext jc = JAXBContext.newInstance(License.class);
			Marshaller marshaller = jc.createMarshaller();
			marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
			StringWriter stringWriter = new StringWriter();
			marshaller.marshal(license, stringWriter);

			// Encrypt with private key
			String content = EncryptDecryptUtils.encrypt(stringWriter.toString(), PRIVATE_KEY);

			// Write in file
			Files.write(Paths.get(dest), content.getBytes());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Loads the license file and fill a License structure. Protocol : - The
	 * license file in parameter has to be generated by the method
	 * generateLicense() of this class.
	 * 
	 * @param src
	 * @return
	 * @throws Exception
	 */
	public void loadLicense(String src) {
		try {
			String encryptedContent = new String(Files.readAllBytes(Paths.get(src)));
			String content = EncryptDecryptUtils.decrypt(encryptedContent, PRIVATE_KEY);
			license = (License) JAXBContext.newInstance(License.class).createUnmarshaller()
			        .unmarshal(new StringReader(content));
		} catch (Exception e) {
			e.printStackTrace();
			license = null;
		}
	}

	public String readKey(String keyFileUrl) {
		try {
			Path keyPath = Paths.get(keyFileUrl);
			String mac = EncryptDecryptUtils.decrypt(new String(Files.readAllBytes(keyPath),
			        "UTF-8"), LicenseService.PRIVATE_KEY);
			return mac;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * Returns the license.
	 * 
	 * @return
	 */
	public License getLicense() {
		return license;
	}

	/**
	 * Returns true if the license is valid (ie the license is present and the
	 * limit date is not reached yet), false otherwise.
	 * 
	 * @return
	 */
	public boolean isLicenseValid() {
		return license == null ? false : license.isValid();
	}

	// Protected visibility for test purpose
	protected void setLicense(License license) {
		this.license = license;
	}

}
