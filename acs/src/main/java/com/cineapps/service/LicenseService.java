/**
 * Copyright (c) 2015 CineApps
 * This source code is the property of CineApps.
 */
package com.cineapps.service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.xml.bind.JAXBException;

import org.apache.log4j.Logger;
import org.quartz.JobKey;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.impl.matchers.GroupMatcher;

import com.cineapps.job.sync.LicenseSynchronizerJob;
import com.cineapps.model.license.License;
import com.cineapps.model.property.LicenseProperty;
import com.cineapps.util.EncryptDecryptUtils;
import com.cineapps.util.SchedulerUtils;
import com.cineapps.util.SystemUtils;

public class LicenseService implements IService {

	private static final Logger logger = Logger.getLogger(LicenseService.class);
	private License license;
	public static final String PRIVATE_KEY = "c76cfb76010511e491910800200c9a66";
	private static final String JOB_GROUP = "LicenseJobGroup";

	// @formatter:off
	/**
	 * Creates a new license file using AES and a private key to encrypt the
	 * content. 
	 * The content is the License instance marshalled into String.
	 */
	// @formatter:on
	public void generateLicense(String mac, Date limitDate, int multiStNbCoins, boolean auxContent,
	        String dest) {
		License license = new License();
		license.setMac(mac);
		license.setLimitDate(limitDate);
		license.setMultiStNbCoins(multiStNbCoins);
		license.setAuxContent(auxContent);

		try {
			String xml = license.marshal();

			// Encrypt with private key
			String content = EncryptDecryptUtils.encrypt(xml, PRIVATE_KEY);

			// Write in file
			Files.write(Paths.get(dest), content.getBytes("UTF-8"));
		} catch (JAXBException | GeneralSecurityException | IOException e) {
			logger.error("Cannot generate a license file to " + dest);
		}
	}

	// @formatter:off
	/**
	 * Loads the license file and creates a License instance. 
	 * Protocol : 
	 *   - The license file in parameter has to be generated by the method
	 * generateLicense() of this class
	 *   - Decrypt the content and unmarshall it into a License instance
	 */
	// @formatter:on
	public void loadLicense(String licenseFileUrl) {
		license = License.fromFile(licenseFileUrl, PRIVATE_KEY);
	}

	/**
	 * Returns the license.
	 * 
	 * @return
	 */
	public License getLicense() {
		return license;
	}

	// @formatter:off
	/**
	 * Generates the acs.key file if it doesn't exist. 
	 * Protocol : 
	 *   - The key is a simple file with the mac address of the host (Twavox). 
	 *   - The content of the key is encrypted with the private key.
	 */
	// @formatter:on
	public void generateKeyIfNeeded(String keyFileUrl) {
		try {
			if (!Files.exists(Paths.get(keyFileUrl))) {
				logger.info("Generate a new key : " + keyFileUrl);
				String mac = SystemUtils.getMacAddress();
				if (mac != null) {
					String encoded = EncryptDecryptUtils.encrypt(mac, PRIVATE_KEY);
					Files.write(Paths.get(keyFileUrl), encoded.getBytes("UTF-8"));
				} else {
					logger.error("Cannot get the mac address");
				}
			}
		} catch (IOException | GeneralSecurityException e) {
			logger.error(e);
		}
	}

	/**
	 * Returns the content in an acs.key file.
	 * 
	 * @param keyFileUrl
	 * @return
	 */
	public String readKey(String keyFileUrl) {
		try {
			Path keyPath = Paths.get(keyFileUrl);
			String mac = EncryptDecryptUtils.decrypt(new String(Files.readAllBytes(keyPath),
			        "UTF-8"), LicenseService.PRIVATE_KEY);
			return mac;
		} catch (Exception e) {
			logger.error(e);
		}
		return null;
	}

	/**
	 * Returns true if the license is valid (ie the license is present and the
	 * limit date is not reached yet), false otherwise.
	 * 
	 * @return
	 */
	public boolean isLicenseValid() {
		return license == null ? false : license.isValid();
	}

	// Protected visibility for test purpose
	protected void setLicense(License license) {
		this.license = license;
	}

	@Override
	public void startProcess() {
		// Checks every day the validity of the license
		LicenseProperty licenseProperty = ServicesHolder.getInstance().getPropertyLoader()
		        .getLicenseProperty();
		LicenseSynchronizerJob.scheduleEveryDay(licenseProperty.getLicenseFileUrl());
	}

	@Override
	public void stopProcess() {
		// Removes all scheduled jobs marked with the JOB_GROUP
		Scheduler scheduler = SchedulerUtils.getScheduler();
		List<JobKey> jobKeys;
		try {
			jobKeys = new ArrayList<>(scheduler.getJobKeys(GroupMatcher
			        .jobGroupEquals(getJobGroup())));
			scheduler.deleteJobs(jobKeys);
		} catch (SchedulerException e) {
			logger.error(e);
		}
	}

	@Override
	public String getJobGroup() {
		return JOB_GROUP;
	}

}
